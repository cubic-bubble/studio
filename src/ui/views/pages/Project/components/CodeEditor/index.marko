
import * as monaco from 'monaco-editor'
import lspClient from './lib/lspClient'
import defineTheme from './lib/defineTheme'
import setupWorkers from './lib/setupWorkers'
import controlActions from './lib/controlActions'
import * as GMLoader from './lib/grammarLoader'

static const defaultOptions = {
  fontSize: 14,
  autoSave: true
}

class {
  onCreate({ file, language, options }){
    this.state = { isMediaFile: false }

    // File input value is explicitly `null` by default
    this.file = file || null
    // Marko is default
    this.language = language || {
      id: 'marko',
      extensions: ['.marko'],
      aliases: ['Marko', 'marko']
    }

    this.options = options || defaultOptions
    this.fs = false
    this.watcher = false
    this.workers = false

    this.editorOptions = {
      model: null,
      lineNumbers: 'on',
      lightbulb: { enabled: true },
      fontSize: this.options.fontSize,
      // theme: 'vs-'+ GState.get('theme'),
      'semanticHighlighting.enabled': true
    }
  }
  onInput({ file, fs }){
    // Re-ajust editor block: Eg. Console close or open
    this.adjustEditorLayout()
    this.fs = fs
    
    // Dispose editor when `file` value is explicitly `null`
    if( file === null && this.editor ){
      this.editor.setModel( null )
      return
    }
    
    // Open new file/model
    if( file && ( !this.file || file.path !== this.file.path ) )
      this.open( this.file = file )
  }
  onMount(){
    this.initMonaco()
    this.open( this.file )

    // Adapt editor container to window resize
    $(window).on( 'resize', () => this.editor.layout() )
    // Adapt editor container to workspace changes
    GState.on( 'ws', () => this.adjustEditorLayout() )
    // Adapt editor theme to workspace theme
    GState.on( 'theme', value => this.editor.updateOptions({ theme: 'vs-'+ value }) )

    // TODO: Properly handle window uncaught errors
    /*
    window.addEventListener( 'error', e => {
      e.preventDefault()


      debugLog('[Editor-Event]', e.message )
    } )
    */
  }
  onDestroy(){
    $(window).off('resize')

    this.editor && this.editor.dispose()
    this.editor_OnDidChangeModel && this.editor_OnDidChangeModel.dispose()
    this.model_OnDidChangeContent && this.model_OnDidChangeContent.dispose()
    this.editor_OnDidBlurEditorText && this.editor_OnDidBlurEditorText.dispose()
    this.editor_OnDidChangeCursorPosition && this.editor_OnDidChangeCursorPosition.dispose()

    if( !this.workers ) return

    const { syntaxWorker } = this.workers
    syntaxWorker.terminate() // Terminate syntax highlighting worker
  }
  setCompilerOptions(){
    const compilerDefaults = {
      reactNamespace: 'React',
      jsxFactory: 'React.createElement',
      jsx: monaco.languages.typescript.JsxEmit.React,
      target: monaco.languages.typescript.ScriptTarget.ES2016,
      allowNonTsExtensions: true,
      moduleResolution: monaco.languages.typescript.ModuleResolutionKind.NodeJs,
      module: monaco.languages.typescript.ModuleKind.System,
      experimentalDecorators: true,
      noEmit: true,
      allowJs: true,
      typeRoots: ['node_modules/@types'],

      forceConsistentCasingInFileNames: false,
      noImplicitReturns: false,
      noImplicitThis: false,
      noImplicitAny: false,
      strictNullChecks: false,
      suppressImplicitAnyIndexErrors: false,
      noUnusedLocals: false,

      newLine: monaco.languages.typescript.NewLineKind.LineFeed
    }
    
    monaco.languages.typescript.typescriptDefaults.setCompilerOptions( compilerDefaults )
    monaco.languages.typescript.javascriptDefaults.setCompilerOptions( compilerDefaults )
  }
  isLoadedModel( path ){
    return this.input
            && this.input.paths.includes( path )
            && !!( monaco.editor.getModel( monaco.Uri.file( path ) ) )
  }
  adjustEditorLayout(){ this.editor && setTimeout( () => this.editor.layout(), 50 ) }
  initMonaco(){
    // Typescript and Javascript Default compiler options
    this.setCompilerOptions()
    
    // Typescript and Javascript Eager Model Sync
    monaco.languages.typescript.typescriptDefaults.setMaximumWorkerIdleTime( -1 )
    monaco.languages.typescript.javascriptDefaults.setMaximumWorkerIdleTime( -1 )
    
    // Typescript and Javascript Eager Model Sync
    monaco.languages.typescript.typescriptDefaults.setEagerModelSync( true )
    monaco.languages.typescript.javascriptDefaults.setEagerModelSync( true )
    
    // Typescript and Javascript Default diagnostics options
    monaco.languages.typescript.typescriptDefaults.setDiagnosticsOptions({
      noSemanticValidation: true,
      noSyntaxValidation: true
    })
    
    // Load custom theme
    defineTheme( monaco )
    // Load language server client
    // lspClient( monaco, this.language )
  }

  async initEditor(){
    try {
      // Load hightlighting language services
      await GMLoader.load()
      // New Editor
      this.editor = monaco.editor.create( this.getEl(), this.editorOptions )
      // Load grammars by editor instance
      await GMLoader.registerGrammar( monaco, this.editor )

      // Load control actions: ContextMenu, KeyControl, ...
      controlActions( monaco, this.editor, this )
      
      /* Capture blur event from editor: 
          NOTE: Works for the whole widget and switching between tabs
      */
      this.editor_OnDidBlurEditorText = this.editor.onDidBlurEditorWidget( () => this.onSave() )
      this.editor_OnDidChangeCursorPosition = this.editor.onDidChangeCursorPosition( ({ position }) => this.emit('cursor-position', position ) )
      this.editor_OnDidChangeModel = this.editor.onDidChangeModel( async ({ newModelUrl, oldModelUrl }) => {
        
        if( oldModelUrl ){
          // Dispose inactive models
          if( !this.isLoadedModel( oldModelUrl.path ) ){
            const model = await this.getModel( oldModelUrl.path )

            model.dispose()
            return
          }
          
          // Auto-save changes on the left model
          this.options.autoSave && this.onSave( await this.getModel( oldModelUrl.path ) )
        }
      } )
    }
    catch( error ){ console.log('[Editor-Event] Error: ', error ) }
  }
  async open( file ){

    // Display media files: Image, Audio, Video
    if( file && /\.(jpe?g|png|gif|webp|mp3|ogg|webm|mp4)$/i.test( file.path ) ){
      await this.setMedia( file )
      return
    }

    // Initialize editor
    !this.editor && await this.initEditor()

    // Listen to events when changes occured on Model outside of the editor
    if( !this.watcher && this.fs )
      this.watcher = this.fs.watch( async ( event, path, stats ) => {
        debugLog(`[Editor-Event] ${event}: ${path}`)

        if( !this.isLoadedModel( path ) ) return

        const model = await this.getModel( path )
        if( !model.file ) return
        
        switch( event ){
          // Cannot overwrite unsaved changes in the editor
          case 'change': !model.file.hasChanges && this.updateModel( model ); break
          case 'unlink': console.log('Unlinked'); break
        }
      } )

    file && this.setModel( file )
  }
  async setMedia( file ){
    // Display media files as image, video, ...
    if( !this.fs ) return

    let base64 = await this.fs.readFile( file.path, { encoding: 'base64' })

    base64 = `data:application/octet-stream;base64,${base64}`

    this.media = {
      ...file,
      src: URL.createObjectURL( await ( await window.fetch( base64 ) ).blob() )
    }
    this.state.isMediaFile = true
  }
  async getModel( path ){
    
    const uri = monaco.Uri.file( path )
    let model = monaco.editor.getModel( uri )
    
    if( !model ){
      content = await this.fs.readFile( path )
      
      model = monaco.editor.createModel( content || '', null, uri )
      //? respect tabSize option in .prettierrc
      // model.updateOptions({ tabSize: 2 })
    }

    return model
  }
  async setModel( file ){

    this.state.isMediaFile = false
    const model = await this.getModel( file.path )
    
    model.file = file
    model.initialContent = model.getValue()

    this.editor.setModel( model )
    this.editor.updateOptions({ tabSize: 2 })
    
    model.onDidChangeContent( () => this.onChange() )
    model.onWillDispose( () => { console.log('Model Will Dispose') } )

    this.activeModel = model
  }
  async updateModel( model ){
    // Update model with its current value
    const content = await this.fs.readFile( model.file.path )
    // Model up-to-date
    if( model.getValue() === content ) return
    
    model.initialContent = content
    model.setValue( content )
  }
  async onChange(){
    debugLog('[Editor-Event] Change:', this.activeModel.file.name )

    const code = this.activeModel.getValue()

    this.activeModel.file.hasChanges = ( code !== this.activeModel.initialContent )
    this.emit( 'change', this.activeModel.file, code )
    
    /*
    if( code ){
      model.pushEditOperations(
        [],
        [
          {
            range: model.getFullModelRange(),
            text: value,
          },
        ]
      );
    }
    */
  }
  async onSave( model ){
    // Save previous changes occured on this model
    model = model || this.activeModel

    if( !model.file.hasChanges ) return
    debugLog('[Editor-Event] Save:', model.file.name )
    
    const code = model.getValue()
    this.emit( 'save', 
                model.file, 
                code,
                () => {
                  model.file.hasChanges = false
                  model.initialContent = code
                } )
  }
}

<!-- Text content editor -->
<div.code-editor no-update></div>

<!-- Media content display -->
<if( state.isMediaFile )>
  <div.position-absolute.top-0.w-100.h-100.theme-bg.d-flex.align-items-center.justify-content-center style="z-index:30">
    <Media ...component.media/>
  </div>
</if>