
import PStore from 'all-localstorage'

static const APITabs = [
  {
    type: 'GET',
    name: 'Test Get Request',
    link: '...'
  },
  {
    active: true,
    type: 'POST',
    name: 'Test Post Request',
    link: '...'
  },
  {
    type: 'PUT',
    name: 'Test Put Request',
    link: '...'
  },
  {
    type: 'DELETE',
    name: 'Test Delete Request',
    link: '...'
  },
  {
    type: 'PATCH',
    name: 'Test Patch Request',
    link: '...'
  },
  {
    type: 'HEAD',
    name: 'Test Head Request',
    link: '...'
  },
  {
    type: 'OPTIONS',
    name: 'Test Options Request',
    link: '...'
  }
]

class {
  onCreate({ params }){
    this.state = {
      workspace: GState.workspaces.get( params.id ),
      project: false,
      
      // Tools dataset
      Code: {},
      API: {},

      // Active indications
      activeTool: 'Code',
      activeElement: null,
      
      emulator: false,
      emulatorError: false,
      emulatorStatus: false,
      
      showAddon: false,
      showSearch: false,
      showConsole: false,
      showExplorer: false,
      showSettings: false,
      showResetProject: false,
      showDeleteProject: false,

      tabs: [],
      layouts: [],
      ongoingSetup: false,
      ongoingProcess: false,

      editorCursorPosition: null
    }

    this.fs = false
    this.pm = false
    this.pstore = false
    this.packager = false
    this.emulator = false

    // Inherit flag from precedent page
    this.flag = uiStore.get('action-flag')
  }
  async onInput({ params }){
    // Fetch project metadata
    await this.getProject( params.id, params.project )
  }
  onAction( action, ...args ){
    switch( action ){
      case 'open': this.Open( ...args ); break
      
      case 'new-dir': 
      case 'new-file':
      case 'move-element':
      case 'rename-element':
      case 'remove-element': this.FSOperator( action, ...args ); break
      case 'cursor-position': this.state.editorCursorPosition = args[0]; break

      case 'run-emulator': this.RunEmulator( ...args ); break
      case 'reload-emulator': this.ReloadEmulator(); break
      case 'quit-emulator': this.QuitEmulator(); break
      
      case 'add-dependency': this.onAddonSelect('dependency'); break
      case 'update-packages':
      case 'remove-packages': 
      case 'refresh-packages': this.PackageOperator( action, ...args ); break
      case 'delete-project': this.DeleteProject(); break
    }
  }
  onSearchToggle( args ){ this.state.showSearch = args }
  onAddonToggle( args ){ this.state.showAddon = args }
  onSettingsToggle( type ){ this.state.showSettings = type }
  onShowResetProjectToggle( type ){ this.state.showResetProject = type }
  onShowDeleteProjectToggle( type ){ this.state.showDeleteProject = type }
  onExplorerToggle( status, fn ){ this.state.showExplorer = status ? { fn } : false }
  onConsoleToggle( status ){
    this.state.showConsole = status

    status !== false ? 
            this.pstore.set('active-console', true )
            : this.pstore.clear('active-console')
  }
  
  onMenuSelect( name ){ this.state.activeTool = name }
  onLayoutChange( blocks ){
    this.state.layouts = blocks
    this.setStateDirty('layouts')
  }
  onAddonSelect( type ){

    switch( type ){
      case 'component': this.onSearchToggle({ filters: { targets: ['component'] } }); break
      case 'dependency': this.onSearchToggle({ filters: { targets: ['package', 'library'] } }); break
      case 'share': this.onSettingsToggle('share'); break
    }

    this.onAddonToggle( false )
  }
  onChangeOccurance( element, changes ){
    // Awarness of changes occured on this activeElement
    if( !this.state.activeElement
        || this.state.activeElement.path !== element.path ) return
    
    this.state.activeElement = element // Has changes or revert to initial content
    this.setStateDirty('activeElement')

    // Show changes on tabs
    this.applyTabsChange( element )
    
    /* TODO: Implement auto-save to prevent lost of changes
              when page get accidentally refreshed
    */



  }

  ongoing( labels ){

    if( labels === false ){
      this.state.ongoingSetup = false
      return
    }
    
    this.state.ongoingSetup = { ...(this.state.ongoingSetup || {}), ...labels }
  }
  progression( stats ){
    // Display ongoing process progression details on Footer
    if( !stats )
      this.state.ongoingProcess = false

    else {
      const { percent, processor, message } = stats

      this.state.ongoingProcess = {
        status: percent == 100 ? 'COMPLETED' : 'ONGOING',
        message: `[${percent}%] ${processor ? processor +': ' : ''}${message}`
      }
    }
  }
  applyTabsChange( arg ){
    // Apply and reflect changes on tabs
    if( typeof arg !== 'object' ) return
    
    Array.isArray( arg ) ?
            this.state.tabs = newObject( arg ) // Update the whole tabs list
            // Change on single tab
            : this.state.tabs = this.state.tabs.map( tab => {
              // Tab already exist
              if( tab.path === arg.path )
                return arg

              return tab
            } )
    
    this.setStateDirty('tabs')
    this.pstore.set('tabs', this.state.tabs )
  }

  Open( element ){
    // Open file, request, ...
    if( !element ){
      this.state.activeElement = null
      this.pstore.clear('active-element')

      return
    }

    this.state.activeElement = { ...element, active: true }
    this.pstore.set('active-element', this.state.activeElement )

    let 
    isActive = false,
    focusIndex,
    counter = 0

    this.state.tabs = this.state.tabs.map( tab => {
      // Tab already exist
      if( tab.path === element.path ){
        // Make tab active
        if( !tab.active ) tab.active = true
        // Changes state of this tab's content
        tab.hasChanges = element.hasChanges
          
        isActive = true
      }
      
      // Off previous active tab
      else if( tab.active ){
        delete tab.active
        focusIndex = counter
      }
      
      counter++
      return tab
    } )
    
    // Add new active tab
    if( !isActive )
      focusIndex === undefined ?
                // At the end of the chain
                this.state.tabs.push( this.state.activeElement )
                // Insert right after the last active tab
                : this.state.tabs.splice( focusIndex + 1, 0, this.state.activeElement )

    this.setStateDirty('tabs')
    this.pstore.set('tabs', this.state.tabs )
  }
  async getProject( workspaceId, projectId ){
    try {
      const { error, message, project } = await RGet(`/workspaces/${workspaceId}/projects/${projectId}`)
      if( error ) throw new Error( message )
      
      this.state.project = project
      // locale store for only this project
      this.pstore = new PStore({ prefix: `cs-${project.name}`, encrypt: true })
      await this.SetupProject()
    }
    catch( error ){
      console.log('Failed retreiving project: ', error )
      this.state.project = null

      this.ongoing({ headline: 'Project Not Found', noLoading: true })
    }
  }
  async getDirectory( path ){
    // Get project directory content
    if( !this.fs ) return

    const dirOptions = {
      ignore: '\\.git|(.+)\\.lock|sandbox|node_modules',
      subdir: true
    }

    this.state.Code.directories = await this.fs.directory( path || null, dirOptions )
    this.state.Code = newObject( this.state.Code )
  }
  async getDependencies(){
    // Get project dependencies in package.json
    if( !this.fs ) return
    
    const packageJson = await this.fs.readFile( 'package.json', { encoding: 'json' } )
    if( !packageJson )
      throw new Error('[Dependency] No package.json file found at the project root')

    const 
    { dependencies, devDependencies } = packageJson,
    deps = [],
    collector = async ( name, version, dev ) => {
      // Get more information about the package in node_modules
      let dep = { name, version: version.replace('^', ''), dev }
      try {
        const { description, repository } = await this.fs.readFile(`./node_modules/${name}/package.json`, { encoding: 'json' } )
        dep = { ...dep, description, repository }
      }
      catch( error ){
        // Failed fetching package.json of the dependency
      }

      deps.push( dep )
    }
    
    for( const name in dependencies )
      await collector( name, dependencies[ name ] )

    for( const name in devDependencies )
      await collector( name, devDependencies[ name ], true )
    
    this.state.Code.dependencies = deps
    this.state.Code = newObject( this.state.Code )
  }
  async initialProjectWS(){
    // Declare filesystem I/O handler at the project's current working directory
    const cwd = this.state.project.specs.code.directory
    this.fs = await window.FileSystem.init( 'project', { cwd, debug: true } )
    // Declare Project's background Process Manager
    this.pm = await window.IProcess.create({ debug: true })

    // Watch external/background operations on this directory
    let wait = 0
    this.fs.watch( async ( event, path, stats ) => {
      debugLog(`[DIRECTORY Event] ${event}: ${path}`, stats )

      switch( event ){
        // New file/dir added: Refresh directory tree
        case 'add':
        case 'addDir': wait && clearTimeout( wait )
                        await this.getDirectory()
            break
        /** Wait for `add` event to conclude file/dir moved: 
            In that case `add event` will refresh the directory.
            otherwise, conclude `delete`
        */
        case 'unlink': wait = setTimeout( async () => await this.getDirectory(), 2000 ); break
                        
      }
    } )

    // Close active ResetProject modal
    this.onShowResetProjectToggle( false )
    // Console to previous show/hide state
    this.state.showConsole = this.pstore.get('active-console')
  }
  async SetupProject( flag ){
    try {
      if( flag ) this.flag = flag
      let AUTORUN = true

      // Initialize project's UI workspace
      await this.initialProjectWS()
      // Load project directory
      await this.getDirectory()
      
      // Project has no directory: Setup or Import (Depending of flag value)
      if( isEmpty( this.state.Code.directories ) ){
        if( !this.flag ){
          // TODO: Prompt modal for user to select project directory or setup new
          this.onShowResetProjectToggle( true )
          return
        }
      }
      // Import if project have no package.json file at the directory root
      else if( !( await this.fs.readFile( 'package.json', { encoding: 'json' } ) ) )
        this.flag = 'import'
      

      // Flag when something fishing about the setup
      if( ['setup', 'import'].includes( this.flag ) ){
        // Importing project from specified repo (import) or setup new (default)
        const action = this.flag || 'setup'

        // Setup a completely new project
        this.ongoing({ headline: 'Setting up the project' })
        await delay(3)
        await this.pm[ action ]( this.state.project, ( error, stats ) => {
          
          
            
          if( error ){
            // TODO: Manage process exception errors
            console.log('--Progress Error: ', error )
            this.ongoing({ error: typeof error == 'object' ? error.message : error })
            return
          }
          
          // TODO: Display progression stats
          this.ongoing({ headline: `[${stats.percent}%] ${stats.message}` })
          this.progression( stats )
        } )

        debugLog('-- Completed indeed --')
        
        // Automatically run project in 3 second
        await delay(3)
        this.ongoing( false )
        AUTORUN && this.RunEmulator( true )
      }
      else {
        // Mount project's last states
        this.state.tabs = this.pstore.get('tabs') || []
        this.state.activeElement = this.pstore.get('active-element') || null
        
        // Reload cached emulator state of this project
        const cachedEMImage = this.pstore.get('emulator')
        if( AUTORUN && cachedEMImage )
          window.env == 'production' ? 
                        this.ReloadEmulator() // Reload backend process
                        : this.RunEmulator() // Connect frontend to process or run process if not available
      }

      // Load project dependencies
      await this.getDependencies()
    }
    catch( error ){
      console.log('Failed setting up project: ', error )
      this.ongoing({ 
        noLoading: true,
        headline: 'Project setup failed', 
        error: error.message
      })
    }
  }
  async DeleteProject(){
    // Close running emulator
    this.ongoing({ headline: 'Dropping all running emulator instances' })
    await this.QuitEmulator()
    await delay(2)

    // Clear store
    this.ongoing({ headline: 'Flushing project cache' })
    this.pstore.flush(`cs-${this.state.project.name}`)
    await delay(3)

    // Clear directory
    this.ongoing({ headline: 'Clearing project directory' })
    await this.fs.remove('')
    this.setState({
      tabs: [],
      Code: {},
      API: {}
    })
    await delay(5)

    // Delete project specs from cubic server
    this.ongoing({ headline: 'Deleting project specifications from cubic servers' })
    try {
      const 
      url = `/workspaces/${this.state.workspace.workspaceId}/projects/${this.state.project.projectId}`,
      { error, message } = await await RDelete( url )

      if( error ) throw new Error( message )
    }
    catch( error ){}
    await delay(3)
    
    // Clear open tabs
    this.ongoing({ headline: 'Clearing project workspace' })
    this.state.project = false
    
    // Reset operators
    this.fs = false
    this.pm = false
    this.packager = false
    this.emulator = false
    await delay(2)
    
    // Move back to workspace
    this.ongoing( false )
    navigate(`/workspace/${this.state.workspace.workspaceId}`)
  }

  async onSave( element, changes, confirmCallback ){
    // Awarness of changes occured on this activeElement
    if( typeof element != 'object'
        || !element.path
        || !element.hasChanges ) return
    
    // Write changes on the disk
    this.fs && await this.fs.newFile( element.path, changes )
    // Show change on tab
    this.applyTabsChange({ ...element, hasChanges: false })
    
    // Confirm element saved to the tool
    typeof confirmCallback == 'function' && confirmCallback()
  }
  async onAddElement( type, element, progress ){
    
    if( !this.pm ){
      debugLog('[AddElement Event] error: Undeclared process manager')
      return
    }

    switch( type ){
      // Copy store component to this project directory
      case 'component': progress( false, 'ONGOING' )
                        const result = await this.pm.addComponents( element, this.state.project.specs.code.directory )
                        result === false ?
                                progress('Unexpected error occured')
                                : progress( false, 'DONE' )
          break
      // Add dependency package to project
      case 'package': await this.PackageOperator( 'add', element )
                      
                      // GlobalSearch callback to confirm process done
                      typeof progress == 'function' && progress()
                      // Wait for global search to clear memory
                      setTimeout( () => this.state.showSearch = false, 500 )
          break
    }
  }

  async FSOperator( type, element ){
    switch( type ){
      case 'new-dir': if( !element.path || !this.fs ) return
                      await this.fs.newDir( element.path )
          break
      case 'new-file': if( !element.path || !this.fs ) return
                      await this.fs.newFile( element.path )
          break
      case 'rename-element': if( !element.path || !element.name || !this.fs ) return
                            await this.fs.rename( element.path, element.name  )
          break
      case 'remove-element': if( !element.path || !this.fs ) return
                            await this.fs.remove( element.path )
          break
      case 'move-element': if( !element.source || !element.destination || !this.fs ) return
                          await this.fs.move( element.source, element.destination )
          break
    }
  }
  async PackageOperator( type, element ){
    
    if( !this.pm ){
      debugLog('[AddElement Event] error: Undeclared process manager')
      return
    }

    type = type.replace('-packages', '')

    const 
    cwd = this.state.project.specs.code.directory,
    progress = ( error, stats ) => {

      if( error ){
        // TODO: Manage process exception errors
        console.log('--Progress Error: ', error )
        return
      }

      // TODO: Display progression stats on Footer
      this.progression( stats )
    }

    this.packager = this.pm.Packager( element, cwd )

    await this.packager[ type ]( progress )
    await this.getDependencies()
  }

  async RunEmulator( force ){
    // Run/Stop emulator
    if( !this.pm ){
      debugLog('[Emulator Event] error: Undeclared process manager')
      return
    }
    
    // Create emulator instance
    if( !this.emulator )
      this.emulator = this.pm.Emulator( this.state.project )

    // Run
    this.state.emulatorStatus = 'loading'
    GState.ws.layout({ mode: 'auto' })
    
    /* Try cached config to reconnect emulator without
      restarting it. Usefull when page got refreshed
      and servers are up
    */
    const cachedEMImage = !force ? this.pstore.get('emulator') : false
    if( cachedEMImage )
      this.state.emulator = cachedEMImage
      
    else {
      const metadata = await this.emulator.run()
      if( !metadata ){
        this.state.emulatorStatus = false
        this.state.emulatorError = 'Emulator failed to run. Check your code and retry'
        return
      }

      this.state.emulator = metadata
    }

    this.state.emulatorStatus = 'running'
    this.pstore.set('emulator', this.state.emulator )
  }
  async ReloadEmulator(){
    // Reload emulator
    if( !this.pm ){
      debugLog('[Emulator Event] error: Undeclared process manager')
      return
    }
    
    // Create emulator instance
    if( !this.emulator )
      this.emulator = this.pm.Emulator( this.state.project )
    
    this.state.emulatorStatus = 'reloading'

    this.state.emulator = await this.emulator.reload()
    this.state.emulatorStatus = 'running'
  }
  async QuitEmulator(){
    // Run/Stop emulator
    if( !this.pm ){
      debugLog('[Emulator Event] error: Undeclared process manager')
      return
    }
    
    if( !this.emulator ){
      debugLog('[Emulator Event] error: No active Emulator found')
      return
    }

    // Quit
    this.state.emulator = false
    this.state.emulatorStatus = 'stopping'
  
    await this.emulator.quit()
    this.state.emulatorStatus = false

    GState.ws.layout({ mode: 'ns' })

    // Clear cached config
    this.pstore.clear('emulator')
  }
}

<div.vh-100>
  <div style="width:calc(100% - 4rem)">
    <Row.no-gutters>
      <!-- Main Block -->
      <div.col.px-0.overflow-hidden.d-flex.align-items-strech>
        <!-- Workspace control tabs -->
        <ControlLayout on-change('onLayoutChange')/>

        <Row.no-gutters style="width:calc(100% - 2rem)">
          <!-- Menu Bar -->
          <Menu show=state.layouts.includes('menu')
                project=state.project
                workspace=state.workspace
                activeTool=state.activeTool
                on-add('onAddonToggle')
                on-select('onMenuSelect')
                on-search('onSearchToggle', true )/>
                      
          <!-- SideBar -->
          <SideBar show=state.layouts.includes('sidebar')
                    type=state.activeTool
                    dataset=state[ state.activeTool ]
                    active=state.activeElement
                    status={
                      emulator: state.emulatorStatus
                    }
                    on-action('onAction')
                    on-show-settings('onSettingsToggle')/>

          <!-- Main Block -->
          <main.main-block.section-block.col.px-0.border-left.overflow-hidden>
            <!-- Tabs Bar -->
            <TabBar type=state.activeTool
                    tabs=state.tabs
                    on-open('Open')
                    on-update('applyTabsChange')/>
            
            <div style="height:calc(100% - 3rem)">
              <div.overflow-hidden class=(state.showConsole ? 'h-75' : 'h-100')>
                <Switch by=state.activeTool>
                  <@case is="Code">
                    <CodeEditor file=state.activeElement
                                paths=state.tabs.map( ({ path }) => { return path } )
                                language=null
                                fs=component.fs
                                on-save('onSave')
                                on-change('onChangeOccurance')
                                on-cursor-position('onAction', 'cursor-position')/>
                  </@case>

                  <@case is="API">
                    <APITestor />
                  </@case>
                </Switch>
              </div>

              <if( state.showConsole )>
                <div.h-25.border-top>
                  <Console project=state.project
                          on-dismiss('onConsoleToggle', false )/>
                </div>
              </if>
            </div>
          </main>
        </Row>

        <!-- Search plugin, app, module, ... from marketplace -->
        <if( state.showSearch )>
          <GlobalSearch ...state.showSearch
                        project=state.project
                        on-return('onAddElement')
                        on-dismiss('onSearchToggle', false )/>
        </if>
      </div>

      <!-- Sandbox Emulator: Model EIS8 -->
      <EIS8 meta=state.emulator
            status=state.emulatorStatus
            error=state.emulatorError
            on-run( 'onAction', 'run-emulator' )
            on-reload( 'onAction', 'reload-emulator' )
            on-quit( 'onAction', 'quit-emulator' )/>
    </Row>
  </div>
  
  <Toolbar />

  <Footer>
    <Row.d-flex.align-items-center>
      <@col>
        <ul.list-inline.m-0>
          <li.px-1.white-text>
            <route-link href=`/workspace/${state.workspace.workspaceId}`>
              ${state.workspace.name}
            </route-link>
          </li>
          <if( state.project )>
            <li.px-1.white-text>${state.project.type.toCapitalCase()}</li>
            <li.px-1.black-text>
              Sync
            </li>
          </if>
        </ul>
      </@col>
      
      <@col.col-8.d-flex.justify-content-end>
        <ul.list-inline.m-0.d-flex.align-items-center>
          <!-- Display ongoing process state -->
          <if( state.ongoingProcess )>
            <li><Progression ...state.ongoingProcess/></li>
          </if>

          <!-- Toggle console display block -->
          <li.px-1.white-text.cursor-pointer on-click('onConsoleToggle', true )>
            Console
          </li>

          <!-- Display main programming language -->
          <if( state.project )>
            <li.px-1.white-text>${state.project.specs.code.language.replace('~', ' ').toCapitalCase()}</li>
          </if>

          <!-- Display editor's cusor current position -->
          <if( state.editorCursorPosition )>
            $ const { lineNumber, column } = state.editorCursorPosition
            <li.px-1.white-text>Ln ${lineNumber}, Col ${column}</li>
          </if>

          <li.px-1.white-text>Spaces: 2</li>
          <li.px-1.white-text>UTF-8</li>
        </ul>
      </@col>
    </Row>
  </Footer>
</div>

<!-- List of element to app to project -->
<if( state.showAddon )>
  <Addon on-select('onAddonSelect')
          on-dismiss('onAddonToggle', false )/>
</if>

<!-- Project settings -->
<if( state.showSettings )>
  <Settings type=state.showSettings
            workspace=state.workspace
            project=state.project
            on-dismiss('onSettingsToggle', false )
            on-delete-toggle('onShowDeleteProjectToggle', true )/>
</if>

<!-- Reset project -->
<if( state.showResetProject )>
  <ResetProject workspace=state.workspace
                project=state.project
                on-continue('getProject')
                on-setup('SetupProject', 'setup')
                on-explorer('onExplorerToggle', true )
                on-dismiss('onShowResetProjectToggle', false )/>
</if>

<!-- Delete project -->
<if( state.showDeleteProject )>
  <DeleteProject workspace=state.workspace
                  project=state.project
                  on-confirm('onAction', 'delete-project')
                  on-dismiss('onShowDeleteProjectToggle', false )/>
</if>

<!-- Show File System Explorer -->
<if( state.showExplorer )>
  <FSExplorer modal
              options={ ignore: '^\\.' }
              ...state.showExplorer
              on-dismiss('onExplorerToggle', false )/>
</if>

<if( state.ongoingSetup )>
  <GLoading ...state.ongoingSetup/>
</if>